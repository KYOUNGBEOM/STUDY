# 개선전 Dockerfile
```docker
FROM diamol/golang 

WORKDIR web
COPY main.go .
COPY index.html .

RUN go build -o /web/server
RUN chmod +x /web/server

CMD ["/web/server"]
ENV USER=sixeyed
EXPOSE 80
```

- docker hub에 올라가 있는 diamol/golang으로부터 이미지 파일을 가져옴
- WORKDIR를 web으로 설정하고 현재 위치한 디렉토리의 main.go 파일과 index.html파일을 복사하여 web 폴더에 저장
- Go 애플리케이션을 빌드하여 실행 파일을 /web/server 경로에 생성
- /web/server 파일에 실행 권한을 부여
- 컨테이너가 실행될 때 /web/server 파일을 실행하도록 설정
- USER라는 환경 변수를 sixeyed로 설정
- 컨테이너가 외부에서 접속할 수 있도록 80번 포트를 엶

![image](https://github.com/user-attachments/assets/2223f600-3ba3-4813-9b1a-751a74b7c3a7)


# 개선 후 Dockerfile
```docker
FROM diamol/golang AS builder

COPY main.go .
RUN go build -o /server
RUN chmod +x /server

# app
FROM diamol/base

EXPOSE 80
CMD ["/server"]
ENV USER="sixeyed"

WORKDIR web
COPY --from=builder /server .
COPY index.html .
```

- Docker Hub에서 diamol/golang 이미지를 가져오고, 이 이미지를 builder라는 이름으로 설정
- main.go 파일을 현재 작업 디렉토리로 복사
- main.go 파일을 컴파일하여 /server 경로에 실행 파일을 생성
- /server 파일에 실행 권한을 추가하여 실행 가능하도록 설정
- 두 번째 스테이지를 시작. diamol/base라는 기본 이미지를 사용하여 최종 실행 환경을 설정
- 컨테이너가 외부에서 접속할 수 있도록 80번 포트를 엶
- 컨테이너가 실행될 때 /server 파일을 실행하도록 설정
- USER라는 환경 변수를 sixeyed로 설정
- WORKDIR를 web으로 설정하고 현재 위치한 디렉토리의 main.go 파일과 index.html파일을 복사하여 web 폴더에 저장

## 차이점
![image](https://github.com/user-attachments/assets/c34a6ea1-8f4d-4b6f-b1d0-51f2980465d8)

- 기존 Dockerfile로 생성한 practice4 이미지는 단일 스테이지에서 빌드와 실행을 모두 처리하기 때문에 <br>
  빌드 도구나 개발 환경이 포함된 용량이 더 큰 이미지가 생성됨
- 개선된 Dockerfile로 생성한 practice1 이미지는 멀티빌드스테이지에서 빌드와 실행을 분리하여 처리하기 때문에 <br>
   

## 이미지 빌드하는 법
### docker build -t 이미지 이름 디렉토리 주소 <br>
    (docker build -t practice .)
### docker build -t 이미지 이름 -f 실행하고자 하는 dockerfile명 디렉토리 주소 <br>
    (docker build -t practice -f docekrfile.optiomized .)
